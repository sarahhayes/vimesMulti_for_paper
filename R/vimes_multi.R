
#' Generates clusters and associated information for two groups
#'
#' @param dat_time numeric column specifying number of days since the first day of interest
#' @param dat_geo1 first geographical coordinate
#' @param dat_geo2 second geographical coordinate
#' @param temporal_cut_offs dataframe of 3 rows and 3 columns specifying temporal cut-offs
#' and proportions for each type of transmission. Either generated by
#' get_quantiles_multi or set_cutoff if user has pre-defined thresholds
#' @param distance_cut_offs dataframe of 3 rows and 3 columns specifying spatial cut-offs
#' and proportions for each type of transmission. Either generated by
#' get_quantiles_multi or set_cutoff if user has pre-defined thresholds
#' @param group_vect vector containing the group that each observation belongs to
#' Entered in same order as observations.
#' @param graph_opt graph options for igraph plots
#' @param ... additional parameters for graph_opt
#'
#' @return a list of 4 components (add more details here)
#' @export
#'
#' @import magrittr
#' @importFrom dplyr select mutate left_join
#' @importFrom  tidyr pivot_wider
#'
#' @examples
#'g1_obs <- 300 # no of cases observed for species 1
#'g2_obs <- 200 # no of cases observed for species 2
#'obs <- g1_obs + g2_obs
#'group_vect <- as.factor(sample(c(rep("g1", g1_obs), rep("g2", g2_obs)), replace = FALSE))
#'dat_time <- round(runif(obs, min = 0, max = 400)) # days from start of study
#'time_dist <- dist(dat_time)
#'dat_geo1 <- runif(obs, min = 372900, max = 656900)
#'dat_geo2 <- runif(obs, min = 8744900, max = 9075900)
#'dat_dist <- as.matrix(c(dat_geo1, dat_geo2))
#'dat_dist <- fields::rdist(dat_dist)/1000 # convert to km
#'dat_x <- list(time_dist, dat_dist)
#'t_cut <- vimesMulti::set_cutoff("temporal", 142, 143, 143)
#'s_cut <- vimesMulti::set_cutoff("spatial", 2.3, 2.3, 2.3)
#'
#'
#' vimes_multi_results_list <- vimes_multi(
#' dat_time = dat_time,
#' dat_geo1 = dat_geo1,
#' dat_geo2 = dat_geo2,
#' temporal_cut_offs = t_cut,
#' distance_cut_offs = s_cut,
#' group_vect = group_vect,
#' graph_opt = vimes::vimes_graph_opt())
#'



vimes_multi <- function(dat_time, dat_geo1, dat_geo2,
                        temporal_cut_offs = NULL, distance_cut_offs = NULL,
                        group_vect = group_vect,
                        graph_opt = vimes::vimes_graph_opt(), ...){

  time_dist <- dist(dat_time)
  dat_dist <- as.matrix(cbind(dat_geo1, dat_geo2))
  dat_dist <- fields::rdist(dat_dist)/1000 # convert to km

  dat_x <- list(time_dist, dat_dist)

  x = vimes::vimes_data(dat_x) # make the data a vimes object

  cuts_temporal_list <- as.list(temporal_cut_offs$threshold_temporal)
  cuts_distance_list <- as.list(distance_cut_offs$threshold_spatial)
  cutoff <- list(cuts_temporal_list, cuts_distance_list)

  ## basic checks
  if(is.null(x)) stop("x is NULL")
  if(!is.list(x)) stop("x is not a list")
  if(!inherits(x, "vimes_data")) stop("x is not a vimes_data object")
  K <- length(x)  # number of types of data in list

  if(!is.null(cutoff)) cutoff <- rep(cutoff, length=K)
  x.labels <- names(x)

  ## MAKE SEPARATE GRAPHS ##
  all_graphs <- list()
  for (i in seq_along(x)) {
    all_graphs[[i]] <- vimes_prune_multi(x[[i]],
                                         cutoff = cutoff[[i]],
                                         group_vect = group_vect,
                                         graph_opt = vimes::vimes_graph_opt())
  }


  ## GET MAIN GRAPH ##
  g <- do.call(igraph::intersection,
               lapply(all_graphs, function(e) e$graph))

  ## set graphical options ##
  ## disable weights
  graph_opt$edge.label <- FALSE
  g <- vimes:::set_igraph_opt(g, graph_opt)

  ## find clusters ##
  groups <- igraph::clusters(g)
  names(groups) <- c("membership", "size", "K")

  ## add cluster colors ##
  groups$color <- graph_opt$col_pal(groups$K)
  names(groups$color) <- 1:groups$K

  ## ADJUST SEPARATE GRAPHS FEATURES ##
  for(i in seq_along(x)){
    ## vertex color ##
    igraph::V(all_graphs[[i]]$graph)$color <- igraph::V(g)$color

    ## layout ##
    all_graphs[[i]]$graph$layout <- g$layout
  }
  names(all_graphs) <- x.labels


  ## The output will contain the main graph, cluster definitions,
  ## the cutoff values used, and then similar information for each
  ## individual graph (one per original distance matrix).

  vimes_results_list <- list(graph = g,
                             clusters = groups,
                             cutoff = cutoff,
                             separate_graphs = all_graphs)

  graph <- vimes_results_list[["graph"]]
  graph_df <- igraph::as_data_frame(graph)
  graph_df <- dplyr::select(graph_df, c(from, to))

  ## assign group to each
  graph_df[,"first_grp"] <-  group_vect[as.numeric(graph_df[,"from"])]
  graph_df[,"second_grp"] <-  group_vect[as.numeric(graph_df[,"to"])]

  graph_df[,"time_first_grp"] <-  dat_time[as.numeric(graph_df[,"from"])]
  graph_df[,"time_second_grp"] <-  dat_time[as.numeric(graph_df[,"to"])]

  graph_df[,"trans"] <- paste(graph_df[,"first_grp"], graph_df[,"second_grp"], sep = "")
  graph_df[which(graph_df$trans %in% c("g1g2", "g2g1")), "trans"] <- "mixed"

  trans_tab_results <- graph_df

  # Generate the number and proportion of each type of transmission

  res_df <- trans_tab_results[,"trans"] %>%
      table() %>%
      as.data.frame() %>%
      magrittr::set_names(c("trans_type", "data_count")) %>%
      dplyr::mutate(data_proportion = data_count/sum(data_count))

    if(sum(res_df$data_proportion) != 1){
      msg <- "Proportions do not sum to 1"
      warning(msg)
      print(sum(res_df$data_proportion))
    #  stop(msg) # ensure sums to 1.
    }

    sim_props <- dplyr::left_join(temporal_cut_offs, distance_cut_offs)

    sim_props[,"sim_proportion"] <- rowMeans(sim_props[,c("proportion_sim_temporal", "proportion_sim_spatial")])
    sum(sim_props$sim_proportion)

    ## make a dataframe combining the simulation proportions and results using the data.
    combined_results <- sim_props %>%
      dplyr::select(trans_type, sim_proportion) %>%
      dplyr::left_join(res_df)  %>%
      dplyr::mutate(sim_count = round(sim_proportion*sum(data_count)))


  # Create a data set from the inputs and add the cluster membership

  dataset <- data.frame(dat_geo1 = dat_geo1, dat_geo2 = dat_geo2,
                        dat_time = dat_time, group_vect = group_vect,
                        cluster_no = vimes_results_list$clusters$membership )

  # Produce a table of the clusters showing how many of each species they contain,
  # what type of transmission they are etc.

    clust_table <- table(dataset$cluster_no)

    no_single <- dataset[dataset$cluster_no %in% names(clust_table[clust_table >=2]),]

    # Now get the cluster composition by group
    cluster_group <- no_single %>%
    dplyr::select(group_vect, cluster_no)
    cluster_group <- as.data.frame(t(table(cluster_group)))
    cluster_group <- tidyr::pivot_wider(cluster_group, names_from = "group_vect", values_from = Freq)
    cluster_group[,"total"] <- rowSums(cluster_group[,c(-1)]) # sum all but the first column
    if(sum(cluster_group[,"total"]) != nrow(no_single)) {print("Warning - numbers in clusters don't match expected numbers")}  # check matches the number we are expecting.

    ## assign the transmission
    cluster_group[which(cluster_group$g1 == cluster_group$total), "trans_type"] <- "g1g1"
    cluster_group[which(cluster_group$g2 == cluster_group$total), "trans_type"] <- "g2g2"
    cluster_group[is.na(cluster_group$trans_type), "trans_type"] <- "mixed"


  return_res <- list(vimes_results_list = vimes_results_list,
                     trans_tab_results = trans_tab_results,
                     combined_results = combined_results,
                     dataset = dataset,
                     cluster_size_df = cluster_group)

}

